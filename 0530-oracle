1.多表查询
	a.笛卡尔积
	两张表不做任何关联产生的数据
	emp
		empno  员工号
		ename  员工名字
		job    职位
		mgr    上司的员工号
		hiredate 入职日期
		sal     薪资
		comm    佣金
		deptno  部门号
	dept
		deptno  部门号
		dname   部门名称
		loc     部门所在位置
	select * from emp;
	select * from dept;
	select * from emp,dept;
	b.内联查询
	语法:
		select 列 from 表1,表2 where 表1.列=表2.列;
		select 列 from 表1 inner join 表2 on 表1.列=表2.列;
	关联列
		名字相同
		作用一致
		主外键关系
	需求:查询SCOTT的部门名称
		1.分析列
			员工名字
			部门名称
		2.分析表
			emp
			dept
		3.关联
			select * from emp e inner join dept d on e.deptno=d.deptno;
		4.过滤
			select d.dname from emp e inner join dept d 
			on e.deptno=d.deptno
			and e.ename='SCOTT';
	需求:查询scott的上司的名字(自联查询)
		select a.ename,b.ename from emp a,emp b 
		where a.mgr=b.empno
		and a.ename='SCOTT';
	c.左联查询、右联查询
		左联:
		select 列 from 左表 left join 右表 on 左表.列=右表.列;
		左联查询左表中所有数据都有
		查询出来结果，内联查询结果+左表中有，右表中没有的，右表对应为空
		create table a(
			a number
		);
		insert into a values(1);
		insert into a values(2);
		insert into a values(3);
		create table b (
			a number,
			b char(10)
		);
		insert into b values(1,'a');
		insert into b values(2,'b');		
		insert into b values(4,'d');
		commit;
		select * from a left join b on a.a=b.a;
		右联:
		select 列 from 左表 right join 右表 on 左表.列=右表.列;
		右联查询是右表中所有数据都有
2.分组查询
	按照某种条件进行分类
	select 列 from 表
		where 条件
			group by 分组条件
				having 分组后过滤条件
	a.分组(聚合)函数
		max()    最大
		min()    最小
		avg()    平均
		sum()    求和
		count()  计数
		需求:查询emp表中最高工资，最低工资，平均工资
		select max(sal),min(sal),avg(sal) from emp;
	b.分组
		select deptno from emp group by deptno;
		select deptno,count(ename) from emp group by deptno;
		需求:查询每个部门地址下有多少员工？
		1>分析列
			部门地址
			员工名字
		2>分析表
			部门地址 dept
			员工名字 emp
		3>关联
			select * from dept d,emp e 
			where d.deptno=e.deptno;
		4>过滤
			select d.loc,count(e.ename) from dept d,emp e 
			where d.deptno=e.deptno
			group by d.loc;
	c.分组后过滤
		having 分组后过滤 可以直接跟分组函数
		where  分组前过滤 不能直接跟分组函数
		需求:查询员工数量超过5的部门地址
			select d.loc,count(e.ename) from dept d,emp e 
			where d.deptno=e.deptno
			group by d.loc
			having count(e.ename)>5;		

